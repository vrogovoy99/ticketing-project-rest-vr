1. Add ResponseWrapper entity for api output
2. Add controller package
3. Add UserController class to handle user related api calls:

    @RestController
    @RequestMapping("/api/v1/user")
    public class UserController {
    }

3.1. Methods like:

        @GetMapping("/{userName}")
        public ResponseEntity<ResponseWrapper> getUserByUserName(@PathVariable("userName") String userName){
            UserDTO userDTO = userService.findByUserName(userName);
            return ResponseEntity.ok(new ResponseWrapper("User found", userDTO, HttpStatus.OK));
        }

3.2. create return status:

    @PostMapping
    public ResponseEntity<ResponseWrapper> createUser(@RequestBody UserDTO userDTO){
        userService.save(userDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(new ResponseWrapper("User created", HttpStatus.CREATED))
    }

3.3. delete return status:

    @DeleteMapping("/{userName}")
    public ResponseEntity<ResponseWrapper> deleteUser (@PathVariable("userName") String userName){
        userService.deleteByUserName(userName);
//        return ResponseEntity.status(HttpStatus.NO_CONTENT).body(new ResponseWrapper("User deleted", HttpStatus.NO_CONTENT));
        return ResponseEntity.ok(new ResponseWrapper("User deleted", HttpStatus.NO_CONTENT));
    }

    NOTE: in case of NO_CONTENT - the body will not be sent with the response.

3.4. Suppress JSON body in case of empty body

    in ResponseWrapper add annotation
    @JsonInclude(JsonInclude.Include.NON_NULL)//JSON will not include body if body is null

3.5. Suppress password in JSON (accept incoming/suppress outgoing

    add in UserDTO class annotation:
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    private String passWord;

3.6. Suppress incoming data in JSON, since it has to be calculated by app:

    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    private int completeTaskCounts;
    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    private int unfinishedTaskCounts;

4. Keycloak setup

4.1. make sure ticketing app is running on port 8081

    add: server.port=8081
    in: application.properties file.

4.2. in GitBash go to  ~/IdeaProjects/spring/keycloak/bin and run  ./standalone.sh

4.3. go to http://localhost:8080/auth/ and login as admin/admin

4.4. add ticketing-app client under Cydeo-dev realm

    Access Type             -   confidential
    Standard Flow Enabled   -   OFF (since we do not have UI)
    Service Accounts Enabled -  ON

4.5. For the client add Roles (same as roles in application):

    Admin
    Manager
    Employee

4.6. Create users

    mike                                ozzy    sam
    Email Verified - ON

    CREDENTIALS:
    password: abc1
    Temporary: OFF

    ROLE MAPPING:
    Client Roles    -   ticketing-app
    Assign Role     -   Manager         Admin   Employee

4.7. add keycloak spring dependency in pom.xml

        <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.keycloak</groupId>
			<artifactId>keycloak-spring-boot-starter</artifactId>
			<version>18.0.0</version>
		</dependency>

4.8. paste keycloak configuration information in application.properties


        keycloak.realm=cydeo-dev
        keycloak.auth-server-url=http://localhost:8080/auth
        keycloak.ssl-required=external
        keycloak.resource=ticketing-app
        keycloak.credentials.secret=6sOJLsuimxvZvvwgrCBCgcDCEY9cVYno
        keycloak.use-resource-role-mappings=true
        keycloak.bearer-only=true
        spring.main.allow-circular-references=true

        master.user=admin
        master.user.password=admin
        master.realm=master
        master.client=master-client

4.9. Copy SecurityConfig.java to com.cydeo.config

4.10. Implement access control in controller files:

4.10.1. UserController:

            @RolesAllowed("Admin")
            public ResponseEntity<ResponseWrapper> getUsers(){

4.10.2. ProjectController:

            @RolesAllowed({"Manager", "Admin"})
            public ResponseEntity<ResponseWrapper> getProjects() {


4.10.3. TaskController....

5. Utilize Keycloak security.

5.1. replace ProjectServiceImpl.java hardcoded user:

        UserDTO currentUserDTO = userService.findByUserName("harold@manager.com");

    with current authenticated user:

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        SimpleKeycloakAccount details = (SimpleKeycloakAccount) authentication.getDetails();
        String username = details.getKeycloakSecurityContext().getToken().getPreferredUsername();
        UserDTO currentUserDTO = userService.findByUserName(username);

5.2. replace TaskServiceImpl.java hardcoded users with the code above.

6. To test security

6.1. setup postman getUser

    GET:            localhost:8081/api/v1/user
    Type:           OAuth 2.0
    Grant Type:     Password Credentials
    Client ID:      ticketing-app
    Client Secret:  secret from Keyclock or application.properties file
    Username:       ozzy
    Password:       abc1

7. Auto security - create security users from application

7.1. Add dependency

        <dependency>
			<groupId>org.keycloak</groupId>
			<artifactId>keycloak-admin-client</artifactId>
			<version>18.0.0</version>
		</dependency>
		<dependency>
			<groupId>org.jboss.spec.javax.ws.rs</groupId>
			<artifactId>jboss-jaxrs-api_2.1_spec</artifactId>
			<version>2.0.1.Final</version>
		</dependency>

7.2. add keycloak admin in application.properties

        master.user=admin
        master.user.password=admin
        master.realm=master
        master.client=master-client

7.2.1. Create master-client in keycloak (required setup for auto security to work)

        Master realm > Clients > Create master-client

7.3. Add com.cydeo.config - KeycloakProperties

8. Create Keycloak Services Implementation

8.1. KeycloakService interface in com.cydeo.service

8.2. KeycloakServiceImpl class in com.cydeo.service.impl

9. After first run change application.properties:

    spring.jpa.hibernate.ddl-auto=update

10. Swagger

10.1. add dependency

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-ui</artifactId>
            <version>1.6.6</version>
        </dependency>

10.2. add SwaggerConfig class in com.cydeo.config

10.3. Since we use authorizationCode flow in SwaggerFonfig.createOAuthFlows, we need to change

10.3.1. Keycloak > Cydeo-dev > clients > ticketing-app > Standard Flow Enabled = ON.

10.3.2. Valid Redirect URIs: http://localhost:8081/*

10.3.3. Web Origins: http://localhost:8081

10.4. Add @Tag and @Operations annotations in controller files. (Optional)

10.5. to run OpenAPI go to http://localhost:8081/swagger-ui/index.html

10.5.1. client - tickeking-app, secret is in application.properties

10.5.2. user login: ozzy/abc1

11. Exceptions

11.1. create exception package and TicketingProjectException extends Exception class AND GlobalExceptionHandler.

    example: UserServiceImpl.delete:

     add throws TicketingProjectException
     add else{ throw new TicketingProjectException("User can not be deleted"); }

11.2. Custom annotation.

11.2.1. In com.cydeo.annotation create Annotation DefaultExceptionMessage
11.2.2. add DefaultExceptionMessageDto

11.3.a setup error handling in UserServiceImpl.checkIfUserCanBeDeleted add


        if (user == null) {
            throw new TicketingProjectException("User not found");
        }

11.3.b UserController annotation to be added in deleteUser method:

     @DefaultExceptionMessage(defaultMessage = "Failed to delete user")

